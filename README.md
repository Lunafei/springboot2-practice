# 스프링 부트와 AWS로 혼자 구현하는 웹 서비스

Spring Boot 맛보기용으로 책 구입하여 연습 

1회차

## 목표

- Spring Boot 알아보기 (기존 Spring과의 경험 비교)
- JPA 사용방법 익히기
- Test 코드 작성에 익숙해지기
- Git 및 GitHub에 익숙해지기
- 책 예제를 통해 CI/CD 체험해보기

## 3장 완료하면서 느낀 점 

**각 Request, Response별로 DTO를 따로 만드는 것**

예제에서는 request, response 별로 dto를 따로 만드는데 이 부분이 인상적이였음

예제처럼 request, response를 따로 관리하고 그 사이에서도 select, insert, update 처럼 각 처리별로
관리하는 것을 보니 이렇게 관리 하는게 dto나 vo의 크기를 쓸데없이 늘리지 않고, 필요한 요소만 쓸 수 있을거 같다.

하지만 SI조직에서는 지금 이 책의 예제처럼 관리되기 힘들다.  개발 가이드를 배포하고, 처음에는 어느정도 지켜지면서
개발이 진행되지만, 시간이 지날수록 점점 시간에 쫓겨 조금씩 규칙이 망가지기 때문이다.  

그럼에도 지금 내가 유지보수 하고 있는 프로젝트의 vo 크기를 생각해보면 앞으로는 어려워도 예제의 방식으로 할 수 있도록 지향하도록 해야겠다.


**JPA**

Mybatis를 사용하고 있는 지금 프로젝트와 비교하여 JPA는 예제만으로도 정말 지금 프로젝트를 JPA로 변경하고 싶을 정도로 만족스러움
(물론 예제만을 경험했기 때문에, 좀 더 깊이 들어가면 어찌 될지는 모르겠지만...)

Mybatis로 개발하다보면 이런저런 상황에 부딪치게 되는데 

- 업무가 비슷한 개발자가 똑같은 쿼리를 여러 쿼리파일에 생성
- 똑같은 쿼리가 있는지 비슷한 업무의 다른 쿼리 파일들에서 쿼리를 찾기 
- 테이블의 특정 Unique key에 따라 조회쿼리를 따로 만들기 or 조회쿼리 안에 unique key 별로 if 문이 달린 쿼리 가 탄생 
- 자신의 업무에 쓸 수 있다고 보여지는 다른업무의 쿼리를 가져다 쓰기 and 가져다 쓰면서 자기 업무에 필요한 부분을 추가하여 타 업무에도 영향이 가게 하기 

등등의 경험을 생각해보면, 객체처럼 데이터를 가져다 쓸 수 있는 JPA는 위와 같은 문제점을 다 해결해 줄 것으로 보인다. (처음 경험해본 뒤의 소감으로)

하지만 공부해야 할 것들이 상당히 많아 보이고, join 등 관계형 데이터베이스에서 사용되는 여러가지들을 배우고자 하면 상당히 어려워보이기도 한다. 

JPA는 좀 더 자세히 배워보고 싶음


## 4장 완료하면서 느낀 점

책에는 단순히 한 테이블의 데이터를 조정하는 수준의 예제의 전부이고, 
책 중간에 실제 업무에서는 조회용 프레임워크를 따로 사용한다고 한다. 

대표적 예로 들었던 것이 

- Querydsl
- jooq
- Mybatis

이 중 Querydsl을 추천해주었다. 

지금 연습하고 있는 예제 프로젝트를 확장하는 단계에서 querydsl을 적용해보고자 한다. 


## 5장 완료하면서 느낀 점

요즘 웹 서비스에는 소셜로그인을 정말 많이 쓰고 있는데 이 부분은 예제를 다시 짜보면서 이해를 더 해봐야 할 필요가 있을거 같다.



## 추가적으로 개발중인 내용

### 댓글 기능

댓글 기능 구현 중, JPA에서 테이블 조인을 어떻게 구성해야 하는지 공부하는 중이다. 

@OneToMany, @ManyToOne 등 Annotation에 대해 공부하는중

어느 케이스일때 어떤 방식으로 구현하는지 아직 확실히 구분이 잘 안가서, 우선 댓글 기능을 구현하면서 테스트를 해보고자 한다.


Comments.java 구현하면서 @OneToMany, @ManyToOne 등에 대해 공부하는중 

Comments Entity 생성 이후 이상한점 및 배운점 정리 

- Comments Entity 생성 이후 서버 실행시 테이블이 생성되기 전 alter table 이 실행 되는 문제점 발견
  (Hibernate: alter table comments drop foreign key FKh4c7lvsc298whoyd4w9ta25cr) 왜 생기는지 이유 확인 필요
- JPA에서 @OneToMany, @ManyToOne 등으로 매핑 되어 있을 경우 조회시 조인 데이터가 바로 조인되는 것이 아니고 FetchType에 따라 다르게 로딩된다.
- Fetch Type 에는 LAZY(FetchType.LAZY)와 EAGER(FetchType.EAGER)가 있다 
- LAZY는 실제 객체를 사용할 때 쿼리로 데이터를 조회한다. 
- EAGER는 즉시 데이터를 조회한다.

아직 이정도까지만 이해한 상황이고, 어떤게 더 좋고 어떨때 써야 하는지는 더 공부해봐야 할거 같다.

이쯤 되니 책에서 말했던 JPA가 배우기 어렵고, 객체지향과 쿼리를 잘 알아야 쓸 수 있다고 하는 것이 어느정도 이해가 가는 중

처음 구동시에 테이블이 생성되기도 전에 alter table이 실행되는 문제도 원인을 찾아봐야 할거 같다. 